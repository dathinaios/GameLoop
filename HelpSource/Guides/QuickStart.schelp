TITLE:: GameLoop Quick Start Guide
categories:: Guide
related:: Overviews/GameLoop_Overview, Classes/GameLoop, SoundEntity

This guide is created as a step by step intro to the main features of the GameLoop library.

section::Basics

We will start simple so be patient until we reach the interesting sounding part. We will need a decoder for the sound output. Eventually there will be a selection of different decoders but for now let's use the Ambisonics to Binaural decoder from the AmbIEM Quark:

code::
GameLoopDecoder('AmbIEM', 'binaural');
::

Now we need to create the environment for our sounds to live in. Let's assign it to the global variable ~gameloop:

code::
~gameloop = GameLoop(40, 40, 1).play(0.05);
::

NOTE::The visuals are intended as a guidance. The environment is meant to be experienced aurally.::

Let's add a sound entity to our environment. At the most basic level an entity has a radius that describes its size and a position in space. We need to create it and activate it.

code::
(
~entity1 = SoundEntity(
	~gameloop.world, 
	position: RealVector2D[18, 22], 
	radius: 0.4, 
); 
~entity1.activate;
)
::

Not very exciting but it is a start. Since we did not specify any input we can hear the default Impulse based sound. we are in the center of the space. Since the space is 40 x 40 the center is (20,20). The sounds appears to be 2 metres left and 2 metres forward. Notice that we had to pass the environment to the SoundEntity (using .world on the GameLoop instance) so that it knows where to add itself. Let's remove the entity:

code::
~entity1.remove;
::

Still working with the default sound let's make it move around.

code::
(
~entity1 = SoundEntity(
  ~gameloop.world, 
  position: RealVector2D[18, 22], 
  radius: 0.4, 
  maxSpeed: 10.0, 
  forceFunc: {arg entity; Arrive.calculate(entity, RealVector2D[20, 20.5])}
); 
~entity1.activate;
)
::

The maxSpeed argument limits the maximum speed of the sound. The motion of the SoundEntity is defined in the forceFunc argument. The arguments expects a function that is passed the entity. In this case the entity is used by the link::Class/Arrive:: Steering behavior. This behavior moves the entity from one place to the other, in this case from the starting position (18,22) to (20, 20.5). 

We can change the forceFunc argument on the fly. Evaluate this a few time to move the entity to random points.

code::
( 
var newVector; 
newVector = RealVector2D[rrand(15.0, 24.0), rrand(15.0, 25.0)];
~entity1.forceFunc_({arg entity; Arrive.calculate(entity, newVector)});
)
::

We are going to have a look at the rest of the Steering behaviors a bit later. For now let's have a look at how the entities can interact with each other. By default entities do not interact but this can be changed by setting their collisionType to /static or /mobile (the default is /free). /mobile entities interact with every other entity while /static entities only interact with /mobile ones. This distinction is useful for preserving processing power.

Let's make two of our default sounding entities collide.

code::
(
~entity1 = SoundEntity(
  ~gameloop.world, 
  position: RealVector2D[25, 20.5], 
  radius: 0.4, 
  maxSpeed: 10.0, 
  forceFunc: {arg entity; Arrive.calculate(entity, RealVector2D[18, 20.5])}
); 
~entity2 = SoundEntity(
  ~gameloop.world, 
  position: RealVector2D[15, 20.5], 
  radius: 0.4, 
  maxSpeed: 10.0, 
  forceFunc: {arg entity; Arrive.calculate(entity, RealVector2D[22, 20.5])}
); 
~entity1.collisionType_(\mobile);
~entity2.collisionType_(\mobile);
~entity1.activate;
~entity2.activate;
)

~entity1.remove;
~entity2.remove;
::

Although we can see the visual feedback that they collide nothing happens in the sound result. The reason is that if we want a result from a collision we also have to define the collisionFunc argument of the SoundEntity. Let's look at a simple example.

code::
(
~entity1 = SoundEntity(
  ~gameloop.world, 
  position: RealVector2D[25, 20.5], 
  radius: 0.4, 
  maxSpeed: 10.0, 
  forceFunc: {arg entity; Arrive.calculate(entity, RealVector2D[18, 20.5])},
	collisionFunc: {arg entList, entity; entity.remove; entList.do{arg i; i.remove}}
); 
~entity2 = SoundEntity(
  ~gameloop.world, 
  position: RealVector2D[15, 20.5], 
  radius: 0.4, 
  maxSpeed: 10.0, 
  forceFunc: {arg entity; Arrive.calculate(entity, RealVector2D[22, 20.5])},
	collisionFunc: {arg entList, entity; entity.remove; entList.do{arg i; i.remove}}
); 

~entity1.collisionType_(\mobile);
~entity2.collisionType_(\mobile);
~entity1.activate;
~entity2.activate;
)

~entity1.remove;
~entity2.remove;
::

The collisionFunc argument is passed a function that expects two arguments: 1) a list of the objects that our entity is colliding with 2) the entity itself. In the above example we simple remove all the entities involved in the collision.
